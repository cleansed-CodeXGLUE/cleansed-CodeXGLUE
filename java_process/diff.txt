diff --git a/.defects4j.config b/.defects4j.config
new file mode 100644
index 00000000..bcc0aa53
--- /dev/null
+++ b/.defects4j.config
@@ -0,0 +1,3 @@
+#File automatically generated by Defects4J
+pid=Lang
+vid=1f
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..90ec22be
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+.svn
diff --git a/defects4j.build.properties b/defects4j.build.properties
new file mode 100644
index 00000000..c758e318
--- /dev/null
+++ b/defects4j.build.properties
@@ -0,0 +1,8 @@
+#File automatically generated by Defects4J
+d4j.bug.id=1
+d4j.classes.modified=org.apache.commons.lang3.math.NumberUtils
+d4j.classes.relevant=org.apache.commons.lang3.math.NumberUtils,org.apache.commons.lang3.StringUtils
+d4j.dir.src.classes=src/main/java
+d4j.dir.src.tests=src/test/java
+d4j.project.id=Lang
+d4j.tests.trigger=org.apache.commons.lang3.math.NumberUtilsTest::TestLang747
diff --git a/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java b/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java
index e021dce9..0cb0c2b4 100644
--- a/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java
@@ -543,40 +543,43 @@ public class LocaleUtilsTest  {
     }
 
     @Test
-    public void testParseAllLocales() {
-        Locale[] locales = Locale.getAvailableLocales();
-        int failures = 0;
-        for (Locale l : locales) {
-            // Check if it's possible to recreate the Locale using just the standard constructor
-            Locale locale = new Locale(l.getLanguage(), l.getCountry(), l.getVariant());
-            if (l.equals(locale)) { // it is possible for LocaleUtils.toLocale to handle these Locales
-                String str = l.toString();
-                // Look for the script/extension suffix
-                int suff = str.indexOf("_#");
-                if (suff == - 1) {
-                    suff = str.indexOf("#");
-                }
-                if (suff >= 0) { // we have a suffix
-                    try {
-                        LocaleUtils.toLocale(str); // shouuld cause IAE
-                        System.out.println("Should not have parsed: " + str);
-                        failures++;
-                        continue; // try next Locale
-                    } catch (IllegalArgumentException iae) {
-                        // expected; try without suffix
-                        str = str.substring(0, suff);
-                    }
-                }
-                Locale loc = LocaleUtils.toLocale(str);
-                if (!l.equals(loc)) {
-                    System.out.println("Failed to parse: " + str);
-                    failures++;
-                }                    
-            }
-        }
-        if (failures > 0) {
-            fail("Failed "+failures+" test(s)");
-        }
-    }
+    public void testParseAllLocales() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testParseAllLocales() {
+//         Locale[] locales = Locale.getAvailableLocales();
+//         int failures = 0;
+//         for (Locale l : locales) {
+//             // Check if it's possible to recreate the Locale using just the standard constructor
+//             Locale locale = new Locale(l.getLanguage(), l.getCountry(), l.getVariant());
+//             if (l.equals(locale)) { // it is possible for LocaleUtils.toLocale to handle these Locales
+//                 String str = l.toString();
+//                 // Look for the script/extension suffix
+//                 int suff = str.indexOf("_#");
+//                 if (suff == - 1) {
+//                     suff = str.indexOf("#");
+//                 }
+//                 if (suff >= 0) { // we have a suffix
+//                     try {
+//                         LocaleUtils.toLocale(str); // shouuld cause IAE
+//                         System.out.println("Should not have parsed: " + str);
+//                         failures++;
+//                         continue; // try next Locale
+//                     } catch (IllegalArgumentException iae) {
+//                         // expected; try without suffix
+//                         str = str.substring(0, suff);
+//                     }
+//                 }
+//                 Locale loc = LocaleUtils.toLocale(str);
+//                 if (!l.equals(loc)) {
+//                     System.out.println("Failed to parse: " + str);
+//                     failures++;
+//                 }                    
+//             }
+//         }
+//         if (failures > 0) {
+//             fail("Failed "+failures+" test(s)");
+//         }
+//     }
 
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java.bak b/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java.bak
new file mode 100644
index 00000000..e021dce9
--- /dev/null
+++ b/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java.bak
@@ -0,0 +1,582 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import static org.apache.commons.lang3.JavaVersion.JAVA_1_4;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Unit tests for {@link LocaleUtils}.
+ *
+ * @version $Id$
+ */
+public class LocaleUtilsTest  {
+
+    private static final Locale LOCALE_EN = new Locale("en", "");
+    private static final Locale LOCALE_EN_US = new Locale("en", "US");
+    private static final Locale LOCALE_EN_US_ZZZZ = new Locale("en", "US", "ZZZZ");
+    private static final Locale LOCALE_FR = new Locale("fr", "");
+    private static final Locale LOCALE_FR_CA = new Locale("fr", "CA");
+    private static final Locale LOCALE_QQ = new Locale("qq", "");
+    private static final Locale LOCALE_QQ_ZZ = new Locale("qq", "ZZ");
+
+
+
+    @Before
+    public void setUp() throws Exception {
+        // Testing #LANG-304. Must be called before availableLocaleSet is called.
+        LocaleUtils.isAvailableLocale(Locale.getDefault());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test that constructors are public, and work, etc.
+     */
+    @Test
+    public void testConstructor() {
+        assertNotNull(new LocaleUtils());
+        final Constructor<?>[] cons = LocaleUtils.class.getDeclaredConstructors();
+        assertEquals(1, cons.length);
+        assertTrue(Modifier.isPublic(cons[0].getModifiers()));
+        assertTrue(Modifier.isPublic(LocaleUtils.class.getModifiers()));
+        assertFalse(Modifier.isFinal(LocaleUtils.class.getModifiers()));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Pass in a valid language, test toLocale.
+     *
+     * @param language  the language string
+     */
+    private void assertValidToLocale(final String language) {
+        final Locale locale = LocaleUtils.toLocale(language);
+        assertNotNull("valid locale", locale);
+        assertEquals(language, locale.getLanguage());
+        //country and variant are empty
+        assertTrue(locale.getCountry() == null || locale.getCountry().isEmpty());
+        assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty());
+    }
+
+    /**
+     * Pass in a valid language, test toLocale.
+     *
+     * @param localeString to pass to toLocale()
+     * @param language of the resulting Locale
+     * @param country of the resulting Locale
+     */
+    private void assertValidToLocale(final String localeString, final String language, final String country) {
+        final Locale locale = LocaleUtils.toLocale(localeString);
+        assertNotNull("valid locale", locale);
+        assertEquals(language, locale.getLanguage());
+        assertEquals(country, locale.getCountry());
+        //variant is empty
+        assertTrue(locale.getVariant() == null || locale.getVariant().isEmpty());
+    }
+
+    /**
+     * Pass in a valid language, test toLocale.
+     *
+     * @param localeString to pass to toLocale()
+     * @param language of the resulting Locale
+     * @param country of the resulting Locale
+     * @param variant of the resulting Locale
+     */
+    private void assertValidToLocale(
+            final String localeString, final String language, 
+            final String country, final String variant) {
+        final Locale locale = LocaleUtils.toLocale(localeString);
+        assertNotNull("valid locale", locale);
+        assertEquals(language, locale.getLanguage());
+        assertEquals(country, locale.getCountry());
+        assertEquals(variant, locale.getVariant());
+        
+    }
+
+    /**
+     * Test toLocale() method.
+     */
+    @Test
+    public void testToLocale_1Part() {
+        assertEquals(null, LocaleUtils.toLocale((String) null));
+        
+        assertValidToLocale("us");
+        assertValidToLocale("fr");
+        assertValidToLocale("de");
+        assertValidToLocale("zh");
+        // Valid format but lang doesnt exist, should make instance anyway
+        assertValidToLocale("qq");
+        
+        try {
+            LocaleUtils.toLocale("Us");
+            fail("Should fail if not lowercase");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("US");
+            fail("Should fail if not lowercase");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("uS");
+            fail("Should fail if not lowercase");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("u#");
+            fail("Should fail if not lowercase");
+        } catch (final IllegalArgumentException iae) {}
+        
+        try {
+            LocaleUtils.toLocale("u");
+            fail("Must be 2 chars if less than 5");
+        } catch (final IllegalArgumentException iae) {}
+       
+        try {
+            LocaleUtils.toLocale("uuu");
+            fail("Must be 2 chars if less than 5");
+        } catch (final IllegalArgumentException iae) {}
+
+        try {
+            LocaleUtils.toLocale("uu_U");
+            fail("Must be 2 chars if less than 5");
+        } catch (final IllegalArgumentException iae) {}
+    }        
+
+    /**
+     * Test toLocale() method.
+     */
+    @Test
+    public void testToLocale_2Part() {
+        assertValidToLocale("us_EN", "us", "EN");
+        //valid though doesnt exist
+        assertValidToLocale("us_ZH", "us", "ZH");
+        
+        try {
+            LocaleUtils.toLocale("us-EN");
+            fail("Should fail as not underscore");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("us_En");
+            fail("Should fail second part not uppercase");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("us_en");
+            fail("Should fail second part not uppercase");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("us_eN");
+            fail("Should fail second part not uppercase");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("uS_EN");
+            fail("Should fail first part not lowercase");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("us_E3");
+            fail("Should fail second part not uppercase");
+        } catch (final IllegalArgumentException iae) {}
+    }        
+
+    /**
+     * Test toLocale() method.
+     */
+    @Test
+    public void testToLocale_3Part() {
+        assertValidToLocale("us_EN_A", "us", "EN", "A");
+        // this isn't pretty, but was caused by a jdk bug it seems
+        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4210525
+        if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) {
+            assertValidToLocale("us_EN_a", "us", "EN", "a");
+            assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFsafdFDsdfF");
+        } else {
+            assertValidToLocale("us_EN_a", "us", "EN", "A");
+            assertValidToLocale("us_EN_SFsafdFDsdfF", "us", "EN", "SFSAFDFDSDFF");
+        }
+        
+        try {
+            LocaleUtils.toLocale("us_EN-a");
+            fail("Should fail as not underscore");
+        } catch (final IllegalArgumentException iae) {}
+        try {
+            LocaleUtils.toLocale("uu_UU_");
+            fail("Must be 3, 5 or 7+ in length");
+        } catch (final IllegalArgumentException iae) {}
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Helper method for local lookups.
+     *
+     * @param locale  the input locale
+     * @param defaultLocale  the input default locale
+     * @param expected  expected results
+     */
+    private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) {
+        final List<Locale> localeList = defaultLocale == null ?
+                LocaleUtils.localeLookupList(locale) :
+                LocaleUtils.localeLookupList(locale, defaultLocale);
+        
+        assertEquals(expected.length, localeList.size());
+        assertEquals(Arrays.asList(expected), localeList);
+        assertUnmodifiableCollection(localeList);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test localeLookupList() method.
+     */
+    @Test
+    public void testLocaleLookupList_Locale() {
+        assertLocaleLookupList(null, null, new Locale[0]);
+        assertLocaleLookupList(LOCALE_QQ, null, new Locale[]{LOCALE_QQ});
+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});
+        assertLocaleLookupList(LOCALE_EN, null, new Locale[]{LOCALE_EN});
+        assertLocaleLookupList(LOCALE_EN_US, null,
+            new Locale[] {
+                LOCALE_EN_US,
+                LOCALE_EN});
+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,
+            new Locale[] {
+                LOCALE_EN_US_ZZZZ,
+                LOCALE_EN_US,
+                LOCALE_EN});
+    }        
+
+    /**
+     * Test localeLookupList() method.
+     */
+    @Test
+    public void testLocaleLookupList_LocaleLocale() {
+        assertLocaleLookupList(LOCALE_QQ, LOCALE_QQ, 
+                new Locale[]{LOCALE_QQ});
+        assertLocaleLookupList(LOCALE_EN, LOCALE_EN, 
+                new Locale[]{LOCALE_EN});
+        
+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_EN_US, 
+            new Locale[]{
+                LOCALE_EN_US,
+                LOCALE_EN});
+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ,
+            new Locale[] {
+                LOCALE_EN_US,
+                LOCALE_EN,
+                LOCALE_QQ});
+        assertLocaleLookupList(LOCALE_EN_US, LOCALE_QQ_ZZ,
+            new Locale[] {
+                LOCALE_EN_US,
+                LOCALE_EN,
+                LOCALE_QQ_ZZ});
+        
+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, null,
+            new Locale[] {
+                LOCALE_EN_US_ZZZZ,
+                LOCALE_EN_US,
+                LOCALE_EN});
+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_EN_US_ZZZZ,
+            new Locale[] {
+                LOCALE_EN_US_ZZZZ,
+                LOCALE_EN_US,
+                LOCALE_EN});
+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ,
+            new Locale[] {
+                LOCALE_EN_US_ZZZZ,
+                LOCALE_EN_US,
+                LOCALE_EN,
+                LOCALE_QQ});
+        assertLocaleLookupList(LOCALE_EN_US_ZZZZ, LOCALE_QQ_ZZ,
+            new Locale[] {
+                LOCALE_EN_US_ZZZZ,
+                LOCALE_EN_US,
+                LOCALE_EN,
+                LOCALE_QQ_ZZ});
+        assertLocaleLookupList(LOCALE_FR_CA, LOCALE_EN,
+            new Locale[] {
+                LOCALE_FR_CA,
+                LOCALE_FR,
+                LOCALE_EN});
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test availableLocaleList() method.
+     */
+    @Test
+    public void testAvailableLocaleList() {
+        final List<Locale> list = LocaleUtils.availableLocaleList();
+        final List<Locale> list2 = LocaleUtils.availableLocaleList();
+        assertNotNull(list);
+        assertSame(list, list2);
+        assertUnmodifiableCollection(list);
+        
+        final Locale[] jdkLocaleArray = Locale.getAvailableLocales();
+        final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);
+        assertEquals(jdkLocaleList, list);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test availableLocaleSet() method.
+     */
+    @Test
+    public void testAvailableLocaleSet() {
+        final Set<Locale> set = LocaleUtils.availableLocaleSet();
+        final Set<Locale> set2 = LocaleUtils.availableLocaleSet();
+        assertNotNull(set);
+        assertSame(set, set2);
+        assertUnmodifiableCollection(set);
+        
+        final Locale[] jdkLocaleArray = Locale.getAvailableLocales();
+        final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);
+        final Set<Locale> jdkLocaleSet = new HashSet<Locale>(jdkLocaleList);
+        assertEquals(jdkLocaleSet, set);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Test availableLocaleSet() method.
+     */
+    @SuppressWarnings("boxing") // JUnit4 does not support primitive equality testing apart from long
+    @Test
+    public void testIsAvailableLocale() {
+        final Set<Locale> set = LocaleUtils.availableLocaleSet();
+        assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));
+        assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));
+        assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));
+        assertEquals(set.contains(LOCALE_FR), LocaleUtils.isAvailableLocale(LOCALE_FR));
+        assertEquals(set.contains(LOCALE_FR_CA), LocaleUtils.isAvailableLocale(LOCALE_FR_CA));
+        assertEquals(set.contains(LOCALE_QQ), LocaleUtils.isAvailableLocale(LOCALE_QQ));
+        assertEquals(set.contains(LOCALE_QQ_ZZ), LocaleUtils.isAvailableLocale(LOCALE_QQ_ZZ));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Make sure the language by country is correct. It checks that 
+     * the LocaleUtils.languagesByCountry(country) call contains the 
+     * array of languages passed in. It may contain more due to JVM 
+     * variations.
+     *
+     * @param country
+     * @param languages array of languages that should be returned
+     */
+    private void assertLanguageByCountry(final String country, final String[] languages) {
+        final List<Locale> list = LocaleUtils.languagesByCountry(country);
+        final List<Locale> list2 = LocaleUtils.languagesByCountry(country);
+        assertNotNull(list);
+        assertSame(list, list2);
+        //search through langauges
+        for (final String language : languages) {
+            final Iterator<Locale> iterator = list.iterator();
+            boolean found = false;
+            // see if it was returned by the set
+            while (iterator.hasNext()) {
+                final Locale locale = iterator.next();
+                // should have an en empty variant
+                assertTrue(locale.getVariant() == null
+                        || locale.getVariant().isEmpty());
+                assertEquals(country, locale.getCountry());
+                if (language.equals(locale.getLanguage())) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                fail("Cound not find language: " + language
+                        + " for country: " + country);
+            }
+        }
+        assertUnmodifiableCollection(list);
+    }
+
+    /**
+     * Test languagesByCountry() method.
+     */
+    @Test
+    public void testLanguagesByCountry() {
+        assertLanguageByCountry(null, new String[0]);
+        assertLanguageByCountry("GB", new String[]{"en"});
+        assertLanguageByCountry("ZZ", new String[0]);
+        assertLanguageByCountry("CH", new String[]{"fr", "de", "it"});
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Make sure the country by language is correct. It checks that 
+     * the LocaleUtils.countryByLanguage(language) call contains the 
+     * array of countries passed in. It may contain more due to JVM 
+     * variations.
+     *
+     *
+     * @param language
+     * @param countries array of countries that should be returned
+     */
+    private void assertCountriesByLanguage(final String language, final String[] countries) {
+        final List<Locale> list = LocaleUtils.countriesByLanguage(language);
+        final List<Locale> list2 = LocaleUtils.countriesByLanguage(language);
+        assertNotNull(list);
+        assertSame(list, list2);
+        //search through langauges
+        for (final String countrie : countries) {
+            final Iterator<Locale> iterator = list.iterator();
+            boolean found = false;
+            // see if it was returned by the set
+            while (iterator.hasNext()) {
+                final Locale locale = iterator.next();
+                // should have an en empty variant
+                assertTrue(locale.getVariant() == null
+                        || locale.getVariant().isEmpty());
+                assertEquals(language, locale.getLanguage());
+                if (countrie.equals(locale.getCountry())) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                fail("Cound not find language: " + countrie
+                        + " for country: " + language);
+            }
+        }
+        assertUnmodifiableCollection(list);
+    }
+
+    /**
+     * Test countriesByLanguage() method.
+     */
+    @Test
+    public void testCountriesByLanguage() {
+        assertCountriesByLanguage(null, new String[0]);
+        assertCountriesByLanguage("de", new String[]{"DE", "CH", "AT", "LU"});
+        assertCountriesByLanguage("zz", new String[0]);
+        assertCountriesByLanguage("it", new String[]{"IT", "CH"});
+    }
+
+    /**
+     * @param coll  the collection to check
+     */
+    private static void assertUnmodifiableCollection(final Collection<?> coll) {
+        try {
+            coll.add(null);
+            fail();
+        } catch (final UnsupportedOperationException ex) {}
+    }
+
+    /**
+     * Tests #LANG-328 - only language+variant
+     */
+    @Test
+    public void testLang328() {
+        assertValidToLocale("fr__P", "fr", "", "P");
+        assertValidToLocale("fr__POSIX", "fr", "", "POSIX");
+    }
+
+    /**
+     * Tests #LANG-865, strings starting with an underscore.
+     */
+    @Test
+    public void testLang865() {
+        assertValidToLocale("_GB", "", "GB", "");
+        assertValidToLocale("_GB_P", "", "GB", "P");
+        assertValidToLocale("_GB_POSIX", "", "GB", "POSIX");
+        try {
+            LocaleUtils.toLocale("_G");
+            fail("Must be at least 3 chars if starts with underscore");
+        } catch (final IllegalArgumentException iae) {
+        }
+        try {
+            LocaleUtils.toLocale("_Gb");
+            fail("Must be uppercase if starts with underscore");
+        } catch (final IllegalArgumentException iae) {
+        }
+        try {
+            LocaleUtils.toLocale("_gB");
+            fail("Must be uppercase if starts with underscore");
+        } catch (final IllegalArgumentException iae) {
+        }
+        try {
+            LocaleUtils.toLocale("_1B");
+            fail("Must be letter if starts with underscore");
+        } catch (final IllegalArgumentException iae) {
+        }
+        try {
+            LocaleUtils.toLocale("_G1");
+            fail("Must be letter if starts with underscore");
+        } catch (final IllegalArgumentException iae) {
+        }
+        try {
+            LocaleUtils.toLocale("_GB_");
+            fail("Must be at least 5 chars if starts with underscore");
+        } catch (final IllegalArgumentException iae) {
+        }
+        try {
+            LocaleUtils.toLocale("_GBAP");
+            fail("Must have underscore after the country if starts with underscore and is at least 5 chars");
+        } catch (final IllegalArgumentException iae) {
+        }
+    }
+
+    @Test
+    public void testParseAllLocales() {
+        Locale[] locales = Locale.getAvailableLocales();
+        int failures = 0;
+        for (Locale l : locales) {
+            // Check if it's possible to recreate the Locale using just the standard constructor
+            Locale locale = new Locale(l.getLanguage(), l.getCountry(), l.getVariant());
+            if (l.equals(locale)) { // it is possible for LocaleUtils.toLocale to handle these Locales
+                String str = l.toString();
+                // Look for the script/extension suffix
+                int suff = str.indexOf("_#");
+                if (suff == - 1) {
+                    suff = str.indexOf("#");
+                }
+                if (suff >= 0) { // we have a suffix
+                    try {
+                        LocaleUtils.toLocale(str); // shouuld cause IAE
+                        System.out.println("Should not have parsed: " + str);
+                        failures++;
+                        continue; // try next Locale
+                    } catch (IllegalArgumentException iae) {
+                        // expected; try without suffix
+                        str = str.substring(0, suff);
+                    }
+                }
+                Locale loc = LocaleUtils.toLocale(str);
+                if (!l.equals(loc)) {
+                    System.out.println("Failed to parse: " + str);
+                    failures++;
+                }                    
+            }
+        }
+        if (failures > 0) {
+            fail("Failed "+failures+" test(s)");
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java
index 420d7bb6..bf2c4e09 100644
--- a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java
@@ -193,97 +193,109 @@ public class RandomStringUtilsTest {
      * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7
      */  
     @Test
-    public void testRandomAlphaNumeric() {
-        final char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};
-        final boolean[] found = {false, false, false, false, false, false};
-        for (int i = 0; i < 100; i++) {
-            final String randString = RandomStringUtils.randomAlphanumeric(10);
-            for (int j = 0; j < testChars.length; j++) {
-                if (randString.indexOf(testChars[j]) > 0) {
-                    found[j] = true;
-                }
-            }
-        }
-        for (int i = 0; i < testChars.length; i++) {
-            if (!found[i]) {
-                fail("alphanumeric character not generated in 1000 attempts: " 
-                   + testChars[i] +" -- repeated failures indicate a problem ");
-            }
-        }
-    }
+    public void testRandomAlphaNumeric() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testRandomAlphaNumeric() {
+//         final char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};
+//         final boolean[] found = {false, false, false, false, false, false};
+//         for (int i = 0; i < 100; i++) {
+//             final String randString = RandomStringUtils.randomAlphanumeric(10);
+//             for (int j = 0; j < testChars.length; j++) {
+//                 if (randString.indexOf(testChars[j]) > 0) {
+//                     found[j] = true;
+//                 }
+//             }
+//         }
+//         for (int i = 0; i < testChars.length; i++) {
+//             if (!found[i]) {
+//                 fail("alphanumeric character not generated in 1000 attempts: " 
+//                    + testChars[i] +" -- repeated failures indicate a problem ");
+//             }
+//         }
+//     }
     
     /**
      * Make sure '0' and '9' are generated by randomNumeric
      * This test will fail randomly with probability = 2 * (9/10)**1000 ~ 3.5E-46
      */  
     @Test
-    public void testRandomNumeric() {
-        final char[] testChars = {'0','9'};
-        final boolean[] found = {false, false};
-        for (int i = 0; i < 100; i++) {
-            final String randString = RandomStringUtils.randomNumeric(10);
-            for (int j = 0; j < testChars.length; j++) {
-                if (randString.indexOf(testChars[j]) > 0) {
-                    found[j] = true;
-                }
-            }
-        }
-        for (int i = 0; i < testChars.length; i++) {
-            if (!found[i]) {
-                fail("digit not generated in 1000 attempts: " 
-                   + testChars[i] +" -- repeated failures indicate a problem ");
-            }
-        }  
-    }
+    public void testRandomNumeric() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testRandomNumeric() {
+//         final char[] testChars = {'0','9'};
+//         final boolean[] found = {false, false};
+//         for (int i = 0; i < 100; i++) {
+//             final String randString = RandomStringUtils.randomNumeric(10);
+//             for (int j = 0; j < testChars.length; j++) {
+//                 if (randString.indexOf(testChars[j]) > 0) {
+//                     found[j] = true;
+//                 }
+//             }
+//         }
+//         for (int i = 0; i < testChars.length; i++) {
+//             if (!found[i]) {
+//                 fail("digit not generated in 1000 attempts: " 
+//                    + testChars[i] +" -- repeated failures indicate a problem ");
+//             }
+//         }  
+//     }
     
     /**
      * Make sure boundary alpha characters are generated by randomAlphabetic
      * This test will fail randomly with probability = 4 * (51/52)**1000 ~ 1.58E-8
      */  
     @Test
-    public void testRandomAlphabetic() {
-        final char[] testChars = {'a', 'z', 'A', 'Z'};
-        final boolean[] found = {false, false, false, false};
-        for (int i = 0; i < 100; i++) {
-            final String randString = RandomStringUtils.randomAlphabetic(10);
-            for (int j = 0; j < testChars.length; j++) {
-                if (randString.indexOf(testChars[j]) > 0) {
-                    found[j] = true;
-                }
-            }
-        }
-        for (int i = 0; i < testChars.length; i++) {
-            if (!found[i]) {
-                fail("alphanumeric character not generated in 1000 attempts: " 
-                   + testChars[i] +" -- repeated failures indicate a problem ");
-            }
-        }
-    }
+    public void testRandomAlphabetic() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testRandomAlphabetic() {
+//         final char[] testChars = {'a', 'z', 'A', 'Z'};
+//         final boolean[] found = {false, false, false, false};
+//         for (int i = 0; i < 100; i++) {
+//             final String randString = RandomStringUtils.randomAlphabetic(10);
+//             for (int j = 0; j < testChars.length; j++) {
+//                 if (randString.indexOf(testChars[j]) > 0) {
+//                     found[j] = true;
+//                 }
+//             }
+//         }
+//         for (int i = 0; i < testChars.length; i++) {
+//             if (!found[i]) {
+//                 fail("alphanumeric character not generated in 1000 attempts: " 
+//                    + testChars[i] +" -- repeated failures indicate a problem ");
+//             }
+//         }
+//     }
     
     /**
      * Make sure 32 and 127 are generated by randomNumeric
      * This test will fail randomly with probability = 2*(95/96)**1000 ~ 5.7E-5
      */  
     @Test
-    public void testRandomAscii() {
-        final char[] testChars = {(char) 32, (char) 126};
-        final boolean[] found = {false, false};
-        for (int i = 0; i < 100; i++) {
-            final String randString = RandomStringUtils.randomAscii(10);
-            for (int j = 0; j < testChars.length; j++) {
-                if (randString.indexOf(testChars[j]) > 0) {
-                    found[j] = true;
-                }
-            }
-        }
-        for (int i = 0; i < testChars.length; i++) {
-            if (!found[i]) {
-                fail("ascii character not generated in 1000 attempts: " 
-                + (int) testChars[i] + 
-                 " -- repeated failures indicate a problem");
-            }
-        }  
-    }
+    public void testRandomAscii() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testRandomAscii() {
+//         final char[] testChars = {(char) 32, (char) 126};
+//         final boolean[] found = {false, false};
+//         for (int i = 0; i < 100; i++) {
+//             final String randString = RandomStringUtils.randomAscii(10);
+//             for (int j = 0; j < testChars.length; j++) {
+//                 if (randString.indexOf(testChars[j]) > 0) {
+//                     found[j] = true;
+//                 }
+//             }
+//         }
+//         for (int i = 0; i < testChars.length; i++) {
+//             if (!found[i]) {
+//                 fail("ascii character not generated in 1000 attempts: " 
+//                 + (int) testChars[i] + 
+//                  " -- repeated failures indicate a problem");
+//             }
+//         }  
+//     }
     
     /** 
      * Test homogeneity of random strings generated --
@@ -292,27 +304,30 @@ public class RandomStringUtilsTest {
      * Repeated failures indicate a problem.
      */
     @Test
-    public void testRandomStringUtilsHomog() {
-        final String set = "abc";
-        final char[] chars = set.toCharArray();
-        String gen = "";
-        final int[] counts = {0,0,0};
-        final int[] expected = {200,200,200};
-        for (int i = 0; i< 100; i++) {
-           gen = RandomStringUtils.random(6,chars);
-           for (int j = 0; j < 6; j++) {
-               switch (gen.charAt(j)) {
-                   case 'a': {counts[0]++; break;}
-                   case 'b': {counts[1]++; break;}
-                   case 'c': {counts[2]++; break;}
-                   default: {fail("generated character not in set");}
-               }
-           }
-        } 
-        // Perform chi-square test with df = 3-1 = 2, testing at .001 level
-        assertTrue("test homogeneity -- will fail about 1 in 1000 times",
-            chiSquare(expected,counts) < 13.82);  
-    }
+    public void testRandomStringUtilsHomog() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testRandomStringUtilsHomog() {
+//         final String set = "abc";
+//         final char[] chars = set.toCharArray();
+//         String gen = "";
+//         final int[] counts = {0,0,0};
+//         final int[] expected = {200,200,200};
+//         for (int i = 0; i< 100; i++) {
+//            gen = RandomStringUtils.random(6,chars);
+//            for (int j = 0; j < 6; j++) {
+//                switch (gen.charAt(j)) {
+//                    case 'a': {counts[0]++; break;}
+//                    case 'b': {counts[1]++; break;}
+//                    case 'c': {counts[2]++; break;}
+//                    default: {fail("generated character not in set");}
+//                }
+//            }
+//         } 
+//         // Perform chi-square test with df = 3-1 = 2, testing at .001 level
+//         assertTrue("test homogeneity -- will fail about 1 in 1000 times",
+//             chiSquare(expected,counts) < 13.82);  
+//     }
     
     /**
      * Computes Chi-Square statistic given observed and expected counts
diff --git a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java.bak b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java.bak
new file mode 100644
index 00000000..420d7bb6
--- /dev/null
+++ b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java.bak
@@ -0,0 +1,361 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.util.Random;
+
+import org.junit.Test;
+
+/**
+ * Unit tests {@link org.apache.commons.lang3.RandomStringUtils}.
+ *
+ * @version $Id$
+ */
+public class RandomStringUtilsTest {
+
+    //-----------------------------------------------------------------------
+    @Test
+    public void testConstructor() {
+        assertNotNull(new RandomStringUtils());
+        final Constructor<?>[] cons = RandomStringUtils.class.getDeclaredConstructors();
+        assertEquals(1, cons.length);
+        assertTrue(Modifier.isPublic(cons[0].getModifiers()));
+        assertTrue(Modifier.isPublic(RandomStringUtils.class.getModifiers()));
+        assertFalse(Modifier.isFinal(RandomStringUtils.class.getModifiers()));
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Test the implementation
+     */
+    @Test
+    public void testRandomStringUtils() {
+        String r1 = RandomStringUtils.random(50);
+        assertEquals("random(50) length", 50, r1.length());
+        String r2 = RandomStringUtils.random(50);
+        assertEquals("random(50) length", 50, r2.length());
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+        
+        r1 = RandomStringUtils.randomAscii(50);
+        assertEquals("randomAscii(50) length", 50, r1.length());
+        for(int i = 0; i < r1.length(); i++) {
+            assertTrue("char between 32 and 127", r1.charAt(i) >= 32 && r1.charAt(i) <= 127);
+        }        
+        r2 = RandomStringUtils.randomAscii(50);
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+
+        r1 = RandomStringUtils.randomAlphabetic(50);
+        assertEquals("randomAlphabetic(50)", 50, r1.length());
+        for(int i = 0; i < r1.length(); i++) {
+            assertTrue("r1 contains alphabetic", Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)));
+        }
+        r2 = RandomStringUtils.randomAlphabetic(50);
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+        
+        r1 = RandomStringUtils.randomAlphanumeric(50);
+        assertEquals("randomAlphanumeric(50)", 50, r1.length());
+        for(int i = 0; i < r1.length(); i++) {
+            assertTrue("r1 contains alphanumeric", Character.isLetterOrDigit(r1.charAt(i)));
+        }
+        r2 = RandomStringUtils.randomAlphabetic(50);
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+        
+        r1 = RandomStringUtils.randomNumeric(50);
+        assertEquals("randomNumeric(50)", 50, r1.length());
+        for(int i = 0; i < r1.length(); i++) {
+            assertTrue("r1 contains numeric", Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)));
+        }
+        r2 = RandomStringUtils.randomNumeric(50);
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+        
+        String set = "abcdefg";
+        r1 = RandomStringUtils.random(50, set);
+        assertEquals("random(50, \"abcdefg\")", 50, r1.length());
+        for(int i = 0; i < r1.length(); i++) {
+            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);
+        }
+        r2 = RandomStringUtils.random(50, set);
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+        
+        r1 = RandomStringUtils.random(50, (String) null);
+        assertEquals("random(50) length", 50, r1.length());
+        r2 = RandomStringUtils.random(50, (String) null);
+        assertEquals("random(50) length", 50, r2.length());
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+        
+        set = "stuvwxyz";
+        r1 = RandomStringUtils.random(50, set.toCharArray());
+        assertEquals("random(50, \"stuvwxyz\")", 50, r1.length());
+        for(int i = 0; i < r1.length(); i++) {
+            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);
+        }
+        r2 = RandomStringUtils.random(50, set);
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+        
+        r1 = RandomStringUtils.random(50, (char[]) null);
+        assertEquals("random(50) length", 50, r1.length());
+        r2 = RandomStringUtils.random(50, (char[]) null);
+        assertEquals("random(50) length", 50, r2.length());
+        assertTrue("!r1.equals(r2)", !r1.equals(r2));
+
+        final long seed = System.currentTimeMillis();
+        r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));
+        r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));
+        assertEquals("r1.equals(r2)", r1, r2);
+
+        r1 = RandomStringUtils.random(0);
+        assertEquals("random(0).equals(\"\")", "", r1);
+    }
+
+    @Test
+    public void testLANG805() {
+        final long seed = System.currentTimeMillis();
+        assertEquals("aaa", RandomStringUtils.random(3,0,0,false,false,new char[]{'a'},new Random(seed)));
+    }
+
+    @Test
+    public void testLANG807() {
+        try {
+            RandomStringUtils.random(3,5,5,false,false);
+            fail("Expected IllegalArgumentException");
+        } catch (final IllegalArgumentException ex) { // distinguish from Random#nextInt message
+            final String msg = ex.getMessage();
+            assertTrue("Message (" + msg + ") must contain 'start'", msg.contains("start"));
+            assertTrue("Message (" + msg + ") must contain 'end'", msg.contains("end"));
+        }
+    }
+
+    @Test
+    public void testExceptions() {
+        final char[] DUMMY = new char[]{'a'}; // valid char array
+        try {
+            RandomStringUtils.random(-1);
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(-1, true, true);
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(-1, DUMMY);
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(-1, "");
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(-1, (String)null);
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(-1, 'a', 'z', false, false);
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY);
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+        try {
+            RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random());
+            fail();
+        } catch (final IllegalArgumentException ex) {}
+    }
+    
+    /**
+     * Make sure boundary alphanumeric characters are generated by randomAlphaNumeric
+     * This test will fail randomly with probability = 6 * (61/62)**1000 ~ 5.2E-7
+     */  
+    @Test
+    public void testRandomAlphaNumeric() {
+        final char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};
+        final boolean[] found = {false, false, false, false, false, false};
+        for (int i = 0; i < 100; i++) {
+            final String randString = RandomStringUtils.randomAlphanumeric(10);
+            for (int j = 0; j < testChars.length; j++) {
+                if (randString.indexOf(testChars[j]) > 0) {
+                    found[j] = true;
+                }
+            }
+        }
+        for (int i = 0; i < testChars.length; i++) {
+            if (!found[i]) {
+                fail("alphanumeric character not generated in 1000 attempts: " 
+                   + testChars[i] +" -- repeated failures indicate a problem ");
+            }
+        }
+    }
+    
+    /**
+     * Make sure '0' and '9' are generated by randomNumeric
+     * This test will fail randomly with probability = 2 * (9/10)**1000 ~ 3.5E-46
+     */  
+    @Test
+    public void testRandomNumeric() {
+        final char[] testChars = {'0','9'};
+        final boolean[] found = {false, false};
+        for (int i = 0; i < 100; i++) {
+            final String randString = RandomStringUtils.randomNumeric(10);
+            for (int j = 0; j < testChars.length; j++) {
+                if (randString.indexOf(testChars[j]) > 0) {
+                    found[j] = true;
+                }
+            }
+        }
+        for (int i = 0; i < testChars.length; i++) {
+            if (!found[i]) {
+                fail("digit not generated in 1000 attempts: " 
+                   + testChars[i] +" -- repeated failures indicate a problem ");
+            }
+        }  
+    }
+    
+    /**
+     * Make sure boundary alpha characters are generated by randomAlphabetic
+     * This test will fail randomly with probability = 4 * (51/52)**1000 ~ 1.58E-8
+     */  
+    @Test
+    public void testRandomAlphabetic() {
+        final char[] testChars = {'a', 'z', 'A', 'Z'};
+        final boolean[] found = {false, false, false, false};
+        for (int i = 0; i < 100; i++) {
+            final String randString = RandomStringUtils.randomAlphabetic(10);
+            for (int j = 0; j < testChars.length; j++) {
+                if (randString.indexOf(testChars[j]) > 0) {
+                    found[j] = true;
+                }
+            }
+        }
+        for (int i = 0; i < testChars.length; i++) {
+            if (!found[i]) {
+                fail("alphanumeric character not generated in 1000 attempts: " 
+                   + testChars[i] +" -- repeated failures indicate a problem ");
+            }
+        }
+    }
+    
+    /**
+     * Make sure 32 and 127 are generated by randomNumeric
+     * This test will fail randomly with probability = 2*(95/96)**1000 ~ 5.7E-5
+     */  
+    @Test
+    public void testRandomAscii() {
+        final char[] testChars = {(char) 32, (char) 126};
+        final boolean[] found = {false, false};
+        for (int i = 0; i < 100; i++) {
+            final String randString = RandomStringUtils.randomAscii(10);
+            for (int j = 0; j < testChars.length; j++) {
+                if (randString.indexOf(testChars[j]) > 0) {
+                    found[j] = true;
+                }
+            }
+        }
+        for (int i = 0; i < testChars.length; i++) {
+            if (!found[i]) {
+                fail("ascii character not generated in 1000 attempts: " 
+                + (int) testChars[i] + 
+                 " -- repeated failures indicate a problem");
+            }
+        }  
+    }
+    
+    /** 
+     * Test homogeneity of random strings generated --
+     * i.e., test that characters show up with expected frequencies
+     * in generated strings.  Will fail randomly about 1 in 1000 times.
+     * Repeated failures indicate a problem.
+     */
+    @Test
+    public void testRandomStringUtilsHomog() {
+        final String set = "abc";
+        final char[] chars = set.toCharArray();
+        String gen = "";
+        final int[] counts = {0,0,0};
+        final int[] expected = {200,200,200};
+        for (int i = 0; i< 100; i++) {
+           gen = RandomStringUtils.random(6,chars);
+           for (int j = 0; j < 6; j++) {
+               switch (gen.charAt(j)) {
+                   case 'a': {counts[0]++; break;}
+                   case 'b': {counts[1]++; break;}
+                   case 'c': {counts[2]++; break;}
+                   default: {fail("generated character not in set");}
+               }
+           }
+        } 
+        // Perform chi-square test with df = 3-1 = 2, testing at .001 level
+        assertTrue("test homogeneity -- will fail about 1 in 1000 times",
+            chiSquare(expected,counts) < 13.82);  
+    }
+    
+    /**
+     * Computes Chi-Square statistic given observed and expected counts
+     * @param observed array of observed frequency counts
+     * @param expected array of expected frequency counts
+     */
+    private double chiSquare(final int[] expected, final int[] observed) {
+        double sumSq = 0.0d;
+        double dev = 0.0d;
+        for (int i = 0; i < observed.length; i++) {
+            dev = observed[i] - expected[i];
+            sumSq += dev * dev / expected[i];
+        }
+        return sumSq;
+    }           
+
+    /**
+     * Checks if the string got by {@link RandomStringUtils#random(int)}
+     * can be converted to UTF-8 and back without loss.
+     *
+     * @see <a href="http://issues.apache.org/jira/browse/LANG-100">LANG-100</a>
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testLang100() throws Exception {
+        final int size = 5000;
+        final String encoding = "UTF-8";
+        final String orig = RandomStringUtils.random(size);
+        final byte[] bytes = orig.getBytes(encoding);
+        final String copy = new String(bytes, encoding);
+
+        // for a verbose compare:
+        for (int i=0; i < orig.length() && i < copy.length(); i++) {
+            final char o = orig.charAt(i);
+            final char c = copy.charAt(i);
+            assertEquals("differs at " + i + "(" + Integer.toHexString(new Character(o).hashCode()) + "," +
+            Integer.toHexString(new Character(c).hashCode()) + ")", o, c);
+        }
+        // compare length also
+        assertEquals(orig.length(), copy.length());
+        // just to be complete
+        assertEquals(orig, copy);
+    }
+}
+
diff --git a/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java b/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java
index ba74ef64..a5a0ea71 100644
--- a/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java
+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java
@@ -310,27 +310,30 @@ public class ToStringBuilderTest {
 
     // Reflection hierarchy tests
     @Test
-    public void testReflectionHierarchyArrayList() {
-        final List<Object> base = new ArrayList<Object>();
-        final String baseStr = this.toBaseString(base);
-        // note, the test data depends on the internal representation of the ArrayList, which may differ between JDK versions and vendors
-        final String expectedWithTransients = baseStr + "[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]";
-        final String toStringWithTransients = ToStringBuilder.reflectionToString(base, null, true);
-        if (!expectedWithTransients.equals(toStringWithTransients)) {
-            // representation different for IBM JDK 1.6.0, LANG-727
-            if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {
-                assertEquals(expectedWithTransients, toStringWithTransients);
-            }
-        }
-        final String expectedWithoutTransients = baseStr + "[size=0]";
-        final String toStringWithoutTransients = ToStringBuilder.reflectionToString(base, null, false);
-        if (!expectedWithoutTransients.equals(toStringWithoutTransients)) {
-            // representation different for IBM JDK 1.6.0, LANG-727
-            if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {
-                assertEquals(expectedWithoutTransients, toStringWithoutTransients);
-            }
-        }
-    }
+    public void testReflectionHierarchyArrayList() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testReflectionHierarchyArrayList() {
+//         final List<Object> base = new ArrayList<Object>();
+//         final String baseStr = this.toBaseString(base);
+//         // note, the test data depends on the internal representation of the ArrayList, which may differ between JDK versions and vendors
+//         final String expectedWithTransients = baseStr + "[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]";
+//         final String toStringWithTransients = ToStringBuilder.reflectionToString(base, null, true);
+//         if (!expectedWithTransients.equals(toStringWithTransients)) {
+//             // representation different for IBM JDK 1.6.0, LANG-727
+//             if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {
+//                 assertEquals(expectedWithTransients, toStringWithTransients);
+//             }
+//         }
+//         final String expectedWithoutTransients = baseStr + "[size=0]";
+//         final String toStringWithoutTransients = ToStringBuilder.reflectionToString(base, null, false);
+//         if (!expectedWithoutTransients.equals(toStringWithoutTransients)) {
+//             // representation different for IBM JDK 1.6.0, LANG-727
+//             if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {
+//                 assertEquals(expectedWithoutTransients, toStringWithoutTransients);
+//             }
+//         }
+//     }
 
     @Test
     public void testReflectionHierarchy() {
diff --git a/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java.bak b/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java.bak
new file mode 100644
index 00000000..ba74ef64
--- /dev/null
+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java.bak
@@ -0,0 +1,1081 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.builder;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang3.SystemUtils;
+import org.junit.After;
+import org.junit.Test;
+
+/**
+ * Unit tests for {@link org.apache.commons.lang3.builder.ToStringBuilder}.
+ *
+ * @version $Id$
+ */
+public class ToStringBuilderTest {
+
+    private final Integer base = Integer.valueOf(5);
+    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));
+
+    /*
+     * All tests should leave the registry empty. 
+     */
+    @After
+    public void after(){
+        validateNullToStringStyleRegistry();
+    }
+
+    //-----------------------------------------------------------------------
+
+    @Test
+    public void testConstructorEx1() {
+        assertEquals("<null>", new ToStringBuilder(null).toString());
+    }
+
+    @Test
+    public void testConstructorEx2() {
+        assertEquals("<null>", new ToStringBuilder(null, null).toString());
+        new ToStringBuilder(this.base, null).toString();
+    }
+
+    @Test
+    public void testConstructorEx3() {
+        assertEquals("<null>", new ToStringBuilder(null, null, null).toString());
+        new ToStringBuilder(this.base, null, null).toString();
+        new ToStringBuilder(this.base, ToStringStyle.DEFAULT_STYLE, null).toString();
+    }
+
+    @Test
+    public void testGetSetDefault() {
+        try {
+            ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);
+            assertSame(ToStringStyle.NO_FIELD_NAMES_STYLE, ToStringBuilder.getDefaultStyle());
+        } finally {
+            // reset for other tests
+            ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);
+        }
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+    public void testSetDefaultEx() {
+        ToStringBuilder.setDefaultStyle(null);
+    }
+
+    @Test
+    public void testBlank() {
+        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());
+    }
+
+    /**
+     * Test wrapper for int primitive.
+     */
+    @Test
+    public void testReflectionInteger() {
+        assertEquals(baseStr + "[value=5]", ToStringBuilder.reflectionToString(base));
+    }
+
+    /**
+     * Test wrapper for char primitive.
+     */
+    @Test
+    public void testReflectionCharacter() {
+        final Character c = new Character('A');
+        assertEquals(this.toBaseString(c) + "[value=A]", ToStringBuilder.reflectionToString(c));
+    }
+
+    /**
+     * Test wrapper for char boolean.
+     */
+    @Test
+    public void testReflectionBoolean() {
+        Boolean b;
+        b = Boolean.TRUE;
+        assertEquals(this.toBaseString(b) + "[value=true]", ToStringBuilder.reflectionToString(b));
+        b = Boolean.FALSE;
+        assertEquals(this.toBaseString(b) + "[value=false]", ToStringBuilder.reflectionToString(b));
+    }
+
+    /**
+     * Create the same toString() as Object.toString().
+     * @param o the object to create the string for.
+     * @return a String in the Object.toString format.
+     */
+    private String toBaseString(final Object o) {
+        return o.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(o));
+    }
+
+    // Reflection Array tests
+
+    //
+    // Note on the following line of code repeated in the reflection array tests.
+    //
+    // assertReflectionArray("<null>", array);
+    //
+    // The expected value is not baseStr + "[<null>]" since array==null and is typed as Object.
+    // The null array does not carry array type information.
+    // If we added a primitive array type constructor and pile of associated methods,
+    // then type declaring type information could be carried forward. IMHO, null is null.
+    //
+    // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com
+    //
+
+    public void assertReflectionArray(final String expected, final Object actual) {
+        if (actual == null) {
+            // Until ToStringBuilder supports null objects.
+            return;
+        }
+        assertEquals(expected, ToStringBuilder.reflectionToString(actual));
+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null));
+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, true));
+        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, false));
+    }
+
+    @Test
+    public void testReflectionObjectArray() {
+        Object[] array = new Object[] { null, base, new int[] { 3, 6 } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{<null>,5,{3,6}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionLongArray() {
+        long[] array = new long[] { 1, 2, -3, 4 };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionIntArray() {
+        int[] array = new int[] { 1, 2, -3, 4 };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionShortArray() {
+        short[] array = new short[] { 1, 2, -3, 4 };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionyteArray() {
+        byte[] array = new byte[] { 1, 2, -3, 4 };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionCharArray() {
+        char[] array = new char[] { 'A', '2', '_', 'D' };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{A,2,_,D}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionDoubleArray() {
+        double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionFloatArray() {
+        float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionBooleanArray() {
+        boolean[] array = new boolean[] { true, false, false };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    // Reflection Array Array tests
+
+    @Test
+    public void testReflectionFloatArrayArray() {
+        float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+
+    @Test
+    public void testReflectionLongArrayArray() {
+        long[][] array = new long[][] { { 1, 2 }, null, { 5 } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionIntArrayArray() {
+        int[][] array = new int[][] { { 1, 2 }, null, { 5 } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionhortArrayArray() {
+        short[][] array = new short[][] { { 1, 2 }, null, { 5 } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionByteArrayArray() {
+        byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionCharArrayArray() {
+        char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionDoubleArrayArray() {
+        double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    @Test
+    public void testReflectionBooleanArrayArray() {
+        boolean[][] array = new boolean[][] { { true, false }, null, { false } };
+        final String baseStr = this.toBaseString(array);
+        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array));
+        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array));
+        array = null;
+        assertReflectionArray("<null>", array);
+    }
+
+    // Reflection hierarchy tests
+    @Test
+    public void testReflectionHierarchyArrayList() {
+        final List<Object> base = new ArrayList<Object>();
+        final String baseStr = this.toBaseString(base);
+        // note, the test data depends on the internal representation of the ArrayList, which may differ between JDK versions and vendors
+        final String expectedWithTransients = baseStr + "[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]";
+        final String toStringWithTransients = ToStringBuilder.reflectionToString(base, null, true);
+        if (!expectedWithTransients.equals(toStringWithTransients)) {
+            // representation different for IBM JDK 1.6.0, LANG-727
+            if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {
+                assertEquals(expectedWithTransients, toStringWithTransients);
+            }
+        }
+        final String expectedWithoutTransients = baseStr + "[size=0]";
+        final String toStringWithoutTransients = ToStringBuilder.reflectionToString(base, null, false);
+        if (!expectedWithoutTransients.equals(toStringWithoutTransients)) {
+            // representation different for IBM JDK 1.6.0, LANG-727
+            if (!("IBM Corporation".equals(SystemUtils.JAVA_VENDOR) && "1.6".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {
+                assertEquals(expectedWithoutTransients, toStringWithoutTransients);
+            }
+        }
+    }
+
+    @Test
+    public void testReflectionHierarchy() {
+        final ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();
+        String baseStr = this.toBaseString(baseA);
+        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA));
+        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null));
+        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false));
+        assertEquals(baseStr + "[a=a,transientA=t]", ToStringBuilder.reflectionToString(baseA, null, true));
+        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, null));
+        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));
+        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));
+
+        final ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();
+        baseStr = this.toBaseString(baseB);
+        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB));
+        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB));
+        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null));
+        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false));
+        assertEquals(baseStr + "[b=b,transientB=t,a=a,transientA=t]", ToStringBuilder.reflectionToString(baseB, null, true));
+        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, null));
+        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));
+        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));
+        assertEquals(baseStr + "[b=b]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));
+    }
+
+    static class ReflectionTestFixtureA {
+        @SuppressWarnings("unused")
+        private final char a='a';
+        @SuppressWarnings("unused")
+        private transient char transientA='t';
+    }
+
+    static class ReflectionTestFixtureB extends ReflectionTestFixtureA {
+        @SuppressWarnings("unused")
+        private final char b='b';
+        @SuppressWarnings("unused")
+        private transient char transientB='t';
+    }
+
+    @Test
+    public void testInnerClassReflection() {
+        final Outer outer = new Outer();
+        assertEquals(toBaseString(outer) + "[inner=" + toBaseString(outer.inner) + "[]]", outer.toString());
+    }
+
+    static class Outer {
+        Inner inner = new Inner();
+        class Inner {
+            @Override
+            public String toString() {
+                return ToStringBuilder.reflectionToString(this);
+            }
+        }
+        @Override
+        public String toString() {
+            return ToStringBuilder.reflectionToString(this);
+        }
+    }
+
+    // Reflection cycle tests
+
+    /**
+     * Test an array element pointing to its container.
+     */
+    @Test
+    public void testReflectionArrayCycle() throws Exception {
+        final Object[] objects = new Object[1];
+        objects[0] = objects;
+        assertEquals(
+            this.toBaseString(objects) + "[{" + this.toBaseString(objects) + "}]",
+            ToStringBuilder.reflectionToString(objects));
+    }
+
+    /**
+     * Test an array element pointing to its container.
+     */
+    @Test
+    public void testReflectionArrayCycleLevel2() throws Exception {
+        final Object[] objects = new Object[1];
+        final Object[] objectsLevel2 = new Object[1];
+        objects[0] = objectsLevel2;
+        objectsLevel2[0] = objects;
+        assertEquals(
+            this.toBaseString(objects) + "[{{" + this.toBaseString(objects) + "}}]",
+            ToStringBuilder.reflectionToString(objects));
+        assertEquals(
+            this.toBaseString(objectsLevel2) + "[{{" + this.toBaseString(objectsLevel2) + "}}]",
+            ToStringBuilder.reflectionToString(objectsLevel2));
+    }
+
+    @Test
+    public void testReflectionArrayArrayCycle() throws Exception {
+        final Object[][] objects = new Object[2][2];
+        objects[0][0] = objects;
+        objects[0][1] = objects;
+        objects[1][0] = objects;
+        objects[1][1] = objects;
+        final String basicToString = this.toBaseString(objects);
+        assertEquals(
+            basicToString
+                + "[{{"
+                + basicToString
+                + ","
+                + basicToString
+                + "},{"
+                + basicToString
+                + ","
+                + basicToString
+                + "}}]",
+            ToStringBuilder.reflectionToString(objects));
+    }
+
+    /**
+     * A reflection test fixture.
+     */
+    static class ReflectionTestCycleA {
+        ReflectionTestCycleB b;
+
+        @Override
+        public String toString() {
+            return ToStringBuilder.reflectionToString(this);
+        }
+    }
+
+    /**
+     * A reflection test fixture.
+     */
+    static class ReflectionTestCycleB {
+        ReflectionTestCycleA a;
+
+        @Override
+        public String toString() {
+            return ToStringBuilder.reflectionToString(this);
+        }
+    }
+
+    /**
+     * A reflection test fixture.
+     */
+    static class SimpleReflectionTestFixture {
+        Object o;
+
+        public SimpleReflectionTestFixture() {
+        }
+
+        public SimpleReflectionTestFixture(final Object o) {
+            this.o = o;
+        }
+
+        @Override
+        public String toString() {
+            return ToStringBuilder.reflectionToString(this);
+        }
+    }
+
+    private static class SelfInstanceVarReflectionTestFixture {
+        @SuppressWarnings("unused")
+        private final SelfInstanceVarReflectionTestFixture typeIsSelf;
+
+        public SelfInstanceVarReflectionTestFixture() {
+            this.typeIsSelf = this;
+        }
+
+        @Override
+        public String toString() {
+            return ToStringBuilder.reflectionToString(this);
+        }
+      }
+
+    private static class SelfInstanceTwoVarsReflectionTestFixture {
+        @SuppressWarnings("unused")
+        private final SelfInstanceTwoVarsReflectionTestFixture typeIsSelf;
+        private final String otherType = "The Other Type";
+
+        public SelfInstanceTwoVarsReflectionTestFixture() {
+            this.typeIsSelf = this;
+        }
+
+        public String getOtherType(){
+            return this.otherType;
+        }
+
+        @Override
+        public String toString() {
+            return ToStringBuilder.reflectionToString(this);
+        }
+      }
+
+
+    /**
+     * Test an Object pointing to itself, the simplest test.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testSimpleReflectionObjectCycle() throws Exception {
+        final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();
+        simple.o = simple;
+        assertEquals(this.toBaseString(simple) + "[o=" + this.toBaseString(simple) + "]", simple.toString());
+    }
+
+    /**
+     * Test a class that defines an ivar pointing to itself.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testSelfInstanceVarReflectionObjectCycle() throws Exception {
+        final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();
+        assertEquals(this.toBaseString(test) + "[typeIsSelf=" + this.toBaseString(test) + "]", test.toString());
+    }
+
+    /**
+     * Test a class that defines an ivar pointing to itself.  This test was
+     * created to show that handling cyclical object resulted in a missing endFieldSeparator call.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {
+        final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();
+        assertEquals(this.toBaseString(test) + "[typeIsSelf=" + this.toBaseString(test) + ",otherType=" + test.getOtherType().toString() + "]", test.toString());
+    }
+
+
+    /**
+     * Test Objects pointing to each other.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testReflectionObjectCycle() throws Exception {
+        final ReflectionTestCycleA a = new ReflectionTestCycleA();
+        final ReflectionTestCycleB b = new ReflectionTestCycleB();
+        a.b = b;
+        b.a = a;
+        assertEquals(
+            this.toBaseString(a) + "[b=" + this.toBaseString(b) + "[a=" + this.toBaseString(a) + "]]",
+            a.toString());
+    }
+
+    /**
+     * Test a nasty combination of arrays and Objects pointing to each other.
+     * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testReflectionArrayAndObjectCycle() throws Exception {
+        final Object[] objects = new Object[1];
+        final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);
+        objects[0] = simple;
+        assertEquals(
+            this.toBaseString(objects)
+                + "[{"
+                + this.toBaseString(simple)
+                + "[o="
+                + this.toBaseString(objects)
+                + "]"
+                + "}]",
+            ToStringBuilder.reflectionToString(objects));
+        assertEquals(
+            this.toBaseString(simple)
+                + "[o={"
+                + this.toBaseString(simple)
+                + "}]",
+            ToStringBuilder.reflectionToString(simple));
+    }
+
+    void validateNullToStringStyleRegistry() {
+        final Map<Object, Object> registry = ToStringStyle.getRegistry();
+        assertNull("Expected null, actual: "+registry, registry);
+    }
+    //  End: Reflection cycle tests
+
+    @Test
+    public void testAppendSuper() {
+        assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());
+
+        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());
+        assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());
+        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());
+    }
+
+    @Test
+    public void testAppendToString() {
+        assertEquals(baseStr + "[]", new ToStringBuilder(base).appendToString("Integer@8888[]").toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").toString());
+
+        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[]").append("a", "hello").toString());
+        assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").append("a", "hello").toString());
+        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString(null).append("a", "hello").toString());
+    }
+
+    @Test
+    public void testObject() {
+        final Integer i3 = Integer.valueOf(3);
+        final Integer i4 = Integer.valueOf(4);
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());
+        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());
+        assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());
+        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());
+        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());
+        assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());
+        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).toString());
+        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).toString());
+        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).toString());
+        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).toString());
+        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());
+        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());
+    }
+    
+    @Test
+    public void testObjectBuild() {
+        final Integer i3 = Integer.valueOf(3);
+        final Integer i4 = Integer.valueOf(4);
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).build());
+        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).build());
+        assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).build());
+        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).build());
+        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).build());
+        assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).build());
+        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), false).build());
+        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList<Object>(), true).build());
+        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), false).build());
+        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap<Object, Object>(), true).build());
+        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).build());
+        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).build());
+    }
+
+    @Test
+    public void testLong() {
+        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());
+        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());
+        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());
+    }
+
+    @SuppressWarnings("cast") // cast is not really needed, keep for consistency
+    @Test
+    public void testInt() {
+        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((int) 3).toString());
+        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (int) 3).toString());
+        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (int) 3).append("b", (int) 4).toString());
+    }
+
+    @Test
+    public void testShort() {
+        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((short) 3).toString());
+        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (short) 3).toString());
+        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (short) 3).append("b", (short) 4).toString());
+    }
+
+    @Test
+    public void testChar() {
+        assertEquals(baseStr + "[A]", new ToStringBuilder(base).append((char) 65).toString());
+        assertEquals(baseStr + "[a=A]", new ToStringBuilder(base).append("a", (char) 65).toString());
+        assertEquals(baseStr + "[a=A,b=B]", new ToStringBuilder(base).append("a", (char) 65).append("b", (char) 66).toString());
+    }
+
+    @Test
+    public void testByte() {
+        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString());
+        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString());
+        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString());
+    }
+
+    @SuppressWarnings("cast")
+    @Test
+    public void testDouble() {
+        assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((double) 3.2).toString());
+        assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (double) 3.2).toString());
+        assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (double) 3.2).append("b", (double) 4.3).toString());
+    }
+
+    @Test
+    public void testFloat() {
+        assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((float) 3.2).toString());
+        assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (float) 3.2).toString());
+        assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (float) 3.2).append("b", (float) 4.3).toString());
+    }
+
+    @Test
+    public void testBoolean() {
+        assertEquals(baseStr + "[true]", new ToStringBuilder(base).append(true).toString());
+        assertEquals(baseStr + "[a=true]", new ToStringBuilder(base).append("a", true).toString());
+        assertEquals(baseStr + "[a=true,b=false]", new ToStringBuilder(base).append("a", true).append("b", false).toString());
+    }
+
+
+    @Test
+    public void testObjectArray() {
+        Object[] array = new Object[] {null, base, new int[] {3, 6}};
+        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testLongArray() {
+        long[] array = new long[] {1, 2, -3, 4};
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testIntArray() {
+        int[] array = new int[] {1, 2, -3, 4};
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testShortArray() {
+        short[] array = new short[] {1, 2, -3, 4};
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testByteArray() {
+        byte[] array = new byte[] {1, 2, -3, 4};
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testCharArray() {
+        char[] array = new char[] {'A', '2', '_', 'D'};
+        assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testDoubleArray() {
+        double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3};
+        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testFloatArray() {
+        float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f};
+        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testBooleanArray() {
+        boolean[] array = new boolean[] {true, false, false};
+        assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testLongArrayArray() {
+        long[][] array = new long[][] {{1, 2}, null, {5}};
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testIntArrayArray() {
+        int[][] array = new int[][] {{1, 2}, null, {5}};
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testShortArrayArray() {
+        short[][] array = new short[][] {{1, 2}, null, {5}};
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testByteArrayArray() {
+        byte[][] array = new byte[][] {{1, 2}, null, {5}};
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testCharArrayArray() {
+        char[][] array = new char[][] {{'A', 'B'}, null, {'p'}};
+        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testDoubleArrayArray() {
+        double[][] array = new double[][] {{1.0, 2.29686}, null, {Double.NaN}};
+        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testFloatArrayArray() {
+        float[][] array = new float[][] {{1.0f, 2.29686f}, null, {Float.NaN}};
+        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testBooleanArrayArray() {
+        boolean[][] array = new boolean[][] {{true, false}, null, {false}};
+        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append((Object) array).toString());
+        array = null;
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());
+        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());
+    }
+
+    @Test
+    public void testObjectCycle() {
+        final ObjectCycle a = new ObjectCycle();
+        final ObjectCycle b = new ObjectCycle();
+        a.obj = b;
+        b.obj = a;
+
+        final String expected = toBaseString(a) + "[" + toBaseString(b) + "[" + toBaseString(a) + "]]";
+        assertEquals(expected, a.toString());
+    }
+
+    static class ObjectCycle {
+        Object obj;
+
+        @Override
+        public String toString() {
+            return new ToStringBuilder(this).append(obj).toString();
+        }
+    }
+
+    @Test
+    public void testSimpleReflectionStatics() {
+        final SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]",
+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]",
+            ReflectionToStringBuilder.toString(instance1, null, true, true, SimpleReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]",
+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345]",
+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));
+    }
+
+    /**
+     * Tests ReflectionToStringBuilder.toString() for statics.
+     */
+    @Test
+    public void testReflectionStatics() {
+        final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]",
+            ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]",
+            ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]",
+            this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]",
+            this.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));
+    }
+
+    /**
+     * Tests ReflectionToStringBuilder.toString() for statics.
+     */
+    @Test
+    public void testInheritedReflectionStatics() {
+        final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890]",
+            ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]",
+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]",
+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));
+        assertEquals(
+            this.toBaseString(instance1) + "[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]",
+            this.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));
+    }
+
+    /**
+     * <p>This method uses reflection to build a suitable
+     * <code>toString</code> value which includes static fields.</p>
+     *
+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
+     * fields. This means that it will throw a security exception if run
+     * under a security manager, if the permissions are not set up correctly.
+     * It is also not as efficient as testing explicitly. </p>
+     *
+     * <p>Transient fields are not output.</p>
+     *
+     * <p>Superclass fields will be appended up to and including the specified superclass.
+     * A null superclass is treated as <code>java.lang.Object</code>.</p>
+     *
+     * <p>If the style is <code>null</code>, the default
+     * <code>ToStringStyle</code> is used.</p>
+     *
+     * @param object  the Object to be output
+     * @param style  the style of the <code>toString</code> to create,
+     *  may be <code>null</code>
+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),
+     *  may be <code>null</code>
+     * @return the String result
+     * @throws IllegalArgumentException if the Object is <code>null</code>
+     */
+    public <T> String toStringWithStatics(final T object, final ToStringStyle style, final Class<? super T> reflectUpToClass) {
+        return ReflectionToStringBuilder.toString(object, style, false, true, reflectUpToClass);
+    }
+
+    /**
+     * Tests ReflectionToStringBuilder setUpToClass().
+     */
+    @Test
+    public void test_setUpToClass_valid() {
+        final Integer val = Integer.valueOf(5);
+        final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);
+        test.setUpToClass(Number.class);
+        test.toString();
+    }
+
+    /**
+     * Tests ReflectionToStringBuilder setUpToClass().
+     */
+    @Test(expected=IllegalArgumentException.class)
+    public void test_setUpToClass_invalid() {
+        final Integer val = Integer.valueOf(5);
+        final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);
+        try {
+            test.setUpToClass(String.class);
+        } finally {
+            test.toString();
+        }
+    }
+
+    /**
+     * Tests ReflectionToStringBuilder.toString() for statics.
+     */
+    class ReflectionStaticFieldsFixture {
+        static final String staticString = "staticString";
+        static final int staticInt = 12345;
+        static final transient String staticTransientString = "staticTransientString";
+        static final transient int staticTransientInt = 54321;
+        String instanceString = "instanceString";
+        int instanceInt = 67890;
+        transient String transientString = "transientString";
+        transient int transientInt = 98765;
+    }
+
+    /**
+     * Test fixture for ReflectionToStringBuilder.toString() for statics.
+     */
+    class SimpleReflectionStaticFieldsFixture {
+        static final String staticString = "staticString";
+        static final int staticInt = 12345;
+    }
+
+    /**
+     * Test fixture for ReflectionToStringBuilder.toString() for statics.
+     */
+    class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture {
+        static final String staticString2 = "staticString2";
+        static final int staticInt2 = 67890;
+    }
+
+    @Test
+    public void testReflectionNull() {
+        assertEquals("<null>", ReflectionToStringBuilder.toString(null));
+    }
+
+    /**
+     * Points out failure to print anything from appendToString methods using MULTI_LINE_STYLE.
+     * See issue LANG-372.
+     */
+    class MultiLineTestObject {
+        Integer i = Integer.valueOf(31337);
+        @Override
+        public String toString() {
+            return new ToStringBuilder(this).append("testInt", i).toString();
+        }
+    }
+
+    @Test
+    public void testAppendToStringUsingMultiLineStyle() {
+        final MultiLineTestObject obj = new MultiLineTestObject();
+        final ToStringBuilder testBuilder = new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)
+                                          .appendToString(obj.toString());
+        assertEquals(testBuilder.toString().indexOf("testInt=31337"), -1);
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java
index bdbff2f0..cfed6c00 100644
--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java
@@ -30,4 +30,6 @@ public class FastDateFormat_ParserTest extends FastDateParserTest {
     protected DateParser getInstance(final String format, final TimeZone timeZone, final Locale locale) {
         return FastDateFormat.getInstance(format, timeZone, locale);
     }
+
+    public void testParseZone() {} // Fails in super class
 }
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java.bak b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java.bak
new file mode 100644
index 00000000..bdbff2f0
--- /dev/null
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java.bak
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * Unit tests for the parse methods of FastDateFormat
+ *
+ * @since 3.2
+ */
+public class FastDateFormat_ParserTest extends FastDateParserTest {
+
+    @Override
+    protected DateParser getInstance(final String format, final TimeZone timeZone, final Locale locale) {
+        return FastDateFormat.getInstance(format, timeZone, locale);
+    }
+}
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java
index 6ab4e22c..d6ac2e98 100644
--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java
@@ -30,4 +30,6 @@ public class FastDateFormat_PrinterTest extends FastDatePrinterTest {
     protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) {
         return FastDateFormat.getInstance(format, timeZone, locale);
     }
+
+    public void testCalendarTimezoneRespected() {} // Fails in super class
 }
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java.bak b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java.bak
new file mode 100644
index 00000000..6ab4e22c
--- /dev/null
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java.bak
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * Unit tests for the print methods of FastDateFormat
+ *
+ * @since 3.2
+ */
+public class FastDateFormat_PrinterTest extends FastDatePrinterTest {
+
+    @Override
+    protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) {
+        return FastDateFormat.getInstance(format, timeZone, locale);
+    }
+}
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
index 59fa3c06..267c012a 100644
--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
@@ -106,28 +106,31 @@ public class FastDateParserTest {
     }
 
     @Test
-    public void testParseZone() throws ParseException {
-        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
-        cal.clear();
-        cal.set(2003, 6, 10, 16, 33, 20);
-
-        final DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US);
-
-        assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 -0500"));
-        assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 GMT-05:00"));
-        assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 Eastern Daylight Time"));
-        assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 EDT"));
-
-        cal.setTimeZone(TimeZone.getTimeZone("GMT-3"));
-        cal.set(2003, 1, 10, 9, 0, 0);
-
-        assertEquals(cal.getTime(), fdf.parse("2003-02-10T09:00:00.000 -0300"));
-
-        cal.setTimeZone(TimeZone.getTimeZone("GMT+5"));
-        cal.set(2003, 1, 10, 15, 5, 6);
-
-        assertEquals(cal.getTime(), fdf.parse("2003-02-10T15:05:06.000 +0500"));
-    }
+    public void testParseZone() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testParseZone() throws ParseException {
+//         final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
+//         cal.clear();
+//         cal.set(2003, 6, 10, 16, 33, 20);
+// 
+//         final DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US);
+// 
+//         assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 -0500"));
+//         assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 GMT-05:00"));
+//         assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 Eastern Daylight Time"));
+//         assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 EDT"));
+// 
+//         cal.setTimeZone(TimeZone.getTimeZone("GMT-3"));
+//         cal.set(2003, 1, 10, 9, 0, 0);
+// 
+//         assertEquals(cal.getTime(), fdf.parse("2003-02-10T09:00:00.000 -0300"));
+// 
+//         cal.setTimeZone(TimeZone.getTimeZone("GMT+5"));
+//         cal.set(2003, 1, 10, 15, 5, 6);
+// 
+//         assertEquals(cal.getTime(), fdf.parse("2003-02-10T15:05:06.000 +0500"));
+//     }
 
     @Test
     public void testParseLongShort() throws ParseException {
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java.bak b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java.bak
new file mode 100644
index 00000000..59fa3c06
--- /dev/null
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java.bak
@@ -0,0 +1,523 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional inparserion regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import java.io.Serializable;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+
+import org.junit.Assert;
+
+import org.apache.commons.lang3.SerializationUtils;
+import org.junit.Test;
+
+/**
+ * Unit tests {@link org.apache.commons.lang3.time.FastDateParser}.
+ *
+ * @since 3.2
+ */
+public class FastDateParserTest {
+    private static final String SHORT_FORMAT_NOERA = "y/M/d/h/a/m/E/Z";
+    private static final String LONG_FORMAT_NOERA = "yyyy/MMMM/dddd/hhhh/mmmm/aaaa/EEEE/ZZZZ";
+    private static final String SHORT_FORMAT = "G/" + SHORT_FORMAT_NOERA;
+    private static final String LONG_FORMAT = "GGGG/" + LONG_FORMAT_NOERA;
+
+    private static final String yMdHmsSZ = "yyyy-MM-dd'T'HH:mm:ss.SSS Z";
+    private static final String DMY_DOT = "dd.MM.yyyy";
+    private static final String YMD_SLASH = "yyyy/MM/dd";
+    private static final String MDY_DASH = "MM-DD-yyyy";
+    private static final String MDY_SLASH = "MM/DD/yyyy";
+
+    private static final TimeZone REYKJAVIK = TimeZone.getTimeZone("Atlantic/Reykjavik");
+    private static final TimeZone NEW_YORK = TimeZone.getTimeZone("America/New_York");
+    private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+
+    private static final Locale SWEDEN = new Locale("sv", "SE");
+
+    DateParser getInstance(final String format) {
+        return getInstance(format, TimeZone.getDefault(), Locale.getDefault());
+    }
+
+    private DateParser getDateInstance(final int dateStyle, final Locale locale) {
+        return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault());
+    }
+
+    private DateParser getInstance(final String format, final Locale locale) {
+        return getInstance(format, TimeZone.getDefault(), locale);
+    }
+
+    private DateParser getInstance(final String format, final TimeZone timeZone) {
+        return getInstance(format, timeZone, Locale.getDefault());
+    }
+
+    /**
+     * Override this method in derived tests to change the construction of instances
+     */
+    protected DateParser getInstance(final String format, final TimeZone timeZone, final Locale locale) {
+        return new FastDateParser(format, timeZone, locale);
+    }
+
+    @Test
+    public void test_Equality_Hash() {
+        final DateParser[] parsers= {
+            getInstance(yMdHmsSZ, NEW_YORK, Locale.US),
+            getInstance(DMY_DOT, NEW_YORK, Locale.US),
+            getInstance(YMD_SLASH, NEW_YORK, Locale.US),
+            getInstance(MDY_DASH, NEW_YORK, Locale.US),
+            getInstance(MDY_SLASH, NEW_YORK, Locale.US),
+            getInstance(MDY_SLASH, REYKJAVIK, Locale.US),
+            getInstance(MDY_SLASH, REYKJAVIK, SWEDEN)
+        };
+
+        final Map<DateParser,Integer> map= new HashMap<DateParser,Integer>();
+        int i= 0;
+        for(final DateParser parser:parsers) {
+            map.put(parser, Integer.valueOf(i++));
+        }
+
+        i= 0;
+        for(final DateParser parser:parsers) {
+            assertEquals(i++, map.get(parser).intValue());
+        }
+    }
+
+    @Test
+    public void testParseZone() throws ParseException {
+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
+        cal.clear();
+        cal.set(2003, 6, 10, 16, 33, 20);
+
+        final DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US);
+
+        assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 -0500"));
+        assertEquals(cal.getTime(), fdf.parse("2003-07-10T15:33:20.000 GMT-05:00"));
+        assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 Eastern Daylight Time"));
+        assertEquals(cal.getTime(), fdf.parse("2003-07-10T16:33:20.000 EDT"));
+
+        cal.setTimeZone(TimeZone.getTimeZone("GMT-3"));
+        cal.set(2003, 1, 10, 9, 0, 0);
+
+        assertEquals(cal.getTime(), fdf.parse("2003-02-10T09:00:00.000 -0300"));
+
+        cal.setTimeZone(TimeZone.getTimeZone("GMT+5"));
+        cal.set(2003, 1, 10, 15, 5, 6);
+
+        assertEquals(cal.getTime(), fdf.parse("2003-02-10T15:05:06.000 +0500"));
+    }
+
+    @Test
+    public void testParseLongShort() throws ParseException {
+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
+        cal.clear();
+        cal.set(2003, 1, 10, 15, 33, 20);
+        cal.set(Calendar.MILLISECOND, 989);
+        cal.setTimeZone(NEW_YORK);
+
+        DateParser fdf = getInstance("yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ", NEW_YORK, Locale.US);
+
+        assertEquals(cal.getTime(), fdf.parse("2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00"));
+        cal.set(Calendar.ERA, GregorianCalendar.BC);
+
+        final Date parse = fdf.parse("2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00");
+                assertEquals(cal.getTime(), parse);
+
+        fdf = getInstance("y G M d a E H m s S Z", NEW_YORK, Locale.US);
+        assertEquals(cal.getTime(), fdf.parse("03 BC 2 10 PM Sat 15 33 20 989 -0500"));
+
+        cal.set(Calendar.ERA, GregorianCalendar.AD);
+        assertEquals(cal.getTime(), fdf.parse("03 AD 2 10 PM Saturday 15 33 20 989 -0500"));
+    }
+
+    @Test
+    public void testAmPm() throws ParseException {
+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
+        cal.clear();
+
+        final DateParser h = getInstance("yyyy-MM-dd hh a mm:ss", NEW_YORK, Locale.US);
+        final DateParser K = getInstance("yyyy-MM-dd KK a mm:ss", NEW_YORK, Locale.US);
+        final DateParser k = getInstance("yyyy-MM-dd kk:mm:ss", NEW_YORK, Locale.US);
+        final DateParser H = getInstance("yyyy-MM-dd HH:mm:ss", NEW_YORK, Locale.US);
+
+        cal.set(2010, 7, 1, 0, 33, 20);
+        assertEquals(cal.getTime(), h.parse("2010-08-01 12 AM 33:20"));
+        assertEquals(cal.getTime(), K.parse("2010-08-01 0 AM 33:20"));
+        assertEquals(cal.getTime(), k.parse("2010-08-01 00:33:20"));
+        assertEquals(cal.getTime(), H.parse("2010-08-01 00:33:20"));
+
+        cal.set(2010, 7, 1, 3, 33, 20);
+        assertEquals(cal.getTime(), h.parse("2010-08-01 3 AM 33:20"));
+        assertEquals(cal.getTime(), K.parse("2010-08-01 3 AM 33:20"));
+        assertEquals(cal.getTime(), k.parse("2010-08-01 03:33:20"));
+        assertEquals(cal.getTime(), H.parse("2010-08-01 03:33:20"));
+
+        cal.set(2010, 7, 1, 15, 33, 20);
+        assertEquals(cal.getTime(), h.parse("2010-08-01 3 PM 33:20"));
+        assertEquals(cal.getTime(), K.parse("2010-08-01 3 PM 33:20"));
+        assertEquals(cal.getTime(), k.parse("2010-08-01 15:33:20"));
+        assertEquals(cal.getTime(), H.parse("2010-08-01 15:33:20"));
+
+        cal.set(2010, 7, 1, 12, 33, 20);
+        assertEquals(cal.getTime(), h.parse("2010-08-01 12 PM 33:20"));
+        assertEquals(cal.getTime(), K.parse("2010-08-01 0 PM 33:20"));
+        assertEquals(cal.getTime(), k.parse("2010-08-01 12:33:20"));
+        assertEquals(cal.getTime(), H.parse("2010-08-01 12:33:20"));
+    }
+
+    @Test
+    // Check that all Locales can parse the formats we use
+    public void testParses() throws Exception {
+        for(final Locale locale : Locale.getAvailableLocales()) {
+            for(final TimeZone tz : new TimeZone[]{NEW_YORK, GMT}) {
+                final Calendar cal = Calendar.getInstance(tz);
+                for(final int year : new int[]{2003, 1940, 1868, 1867, 0, -1940}) {
+                    // http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html
+                    if (year < 1868 && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {
+                        continue; // Japanese imperial calendar does not support eras before 1868
+                    }
+                    cal.clear();
+                    if (year < 0) {
+                        cal.set(-year, 1, 10);
+                        cal.set(Calendar.ERA, GregorianCalendar.BC);
+                    } else {
+                        cal.set(year, 1, 10);
+                    }
+                    final Date in = cal.getTime();
+                    for(final String format : new String[]{LONG_FORMAT, SHORT_FORMAT}) {
+                        final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);
+                        if (format.equals(SHORT_FORMAT)) {
+                            if (year < 1930) {
+                                sdf.set2DigitYearStart(cal.getTime());
+                            }
+                        }
+                        final String fmt = sdf.format(in);
+                        try {
+                            final Date out = sdf.parse(fmt);
+
+                            assertEquals(locale.toString()+" "+year+" "+ format+ " "+tz.getID(), in, out);
+                        } catch (final ParseException pe) {
+                            System.out.println(fmt+" "+locale.toString()+" "+year+" "+ format+ " "+tz.getID());
+                            throw pe;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testLocales_Long_AD() throws Exception {
+        testLocales(LONG_FORMAT, false);
+    }
+
+    @Test
+    public void testLocales_Long_BC() throws Exception {
+        testLocales(LONG_FORMAT, true);
+    }
+
+    @Test
+    public void testLocales_Short_AD() throws Exception {
+        testLocales(SHORT_FORMAT, false);
+    }
+
+    @Test
+    public void testLocales_Short_BC() throws Exception {
+        testLocales(SHORT_FORMAT, true);
+    }
+
+    @Test
+    public void testLocales_LongNoEra_AD() throws Exception {
+        testLocales(LONG_FORMAT_NOERA, false);
+    }
+
+    @Test
+    public void testLocales_LongNoEra_BC() throws Exception {
+        testLocales(LONG_FORMAT_NOERA, true);
+    }
+
+    @Test
+    public void testLocales_ShortNoEra_AD() throws Exception {
+        testLocales(SHORT_FORMAT_NOERA, false);
+    }
+
+    @Test
+    public void testLocales_ShortNoEra_BC() throws Exception {
+        testLocales(SHORT_FORMAT_NOERA, true);
+    }
+
+    private void testLocales(final String format, final boolean eraBC) throws Exception {
+
+        final Calendar cal= Calendar.getInstance(GMT);
+        cal.clear();
+        cal.set(2003, 1, 10);
+        if (eraBC) {
+            cal.set(Calendar.ERA, GregorianCalendar.BC);
+        }
+        for(final Locale locale : Locale.getAvailableLocales()) {
+            // ja_JP_JP cannot handle dates before 1868 properly
+            if (eraBC && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {
+                continue;
+            }
+            final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);
+            final DateParser fdf = getInstance(format, locale);
+
+            try {
+                checkParse(locale, cal, sdf, fdf);
+            } catch(final ParseException ex) {
+                Assert.fail("Locale "+locale+ " failed with "+format+" era "+(eraBC?"BC":"AD")+"\n" + trimMessage(ex.toString()));
+            }
+        }
+    }
+
+    private String trimMessage(final String msg) {
+        if (msg.length() < 100) {
+            return msg;
+        }
+        final int gmt = msg.indexOf("(GMT");
+        if (gmt > 0) {
+            return msg.substring(0, gmt+4)+"...)";
+        }
+        return msg.substring(0, 100)+"...";
+    }
+
+    private void checkParse(final Locale locale, final Calendar cal, final SimpleDateFormat sdf, final DateParser fdf) throws ParseException {
+        final String formattedDate= sdf.format(cal.getTime());
+        final Date expectedTime = sdf.parse(formattedDate);
+        final Date actualTime = fdf.parse(formattedDate);
+        assertEquals(locale.toString()+" "+formattedDate
+                +"\n",expectedTime, actualTime);
+    }
+
+    @Test
+    public void testParseNumerics() throws ParseException {
+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
+        cal.clear();
+        cal.set(2003, 1, 10, 15, 33, 20);
+        cal.set(Calendar.MILLISECOND, 989);
+
+        final DateParser fdf = getInstance("yyyyMMddHHmmssSSS", NEW_YORK, Locale.US);
+        assertEquals(cal.getTime(), fdf.parse("20030210153320989"));
+    }
+
+    @Test
+    public void testQuotes() throws ParseException {
+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
+        cal.clear();
+        cal.set(2003, 1, 10, 15, 33, 20);
+        cal.set(Calendar.MILLISECOND, 989);
+
+        final DateParser fdf = getInstance("''yyyyMMdd'A''B'HHmmssSSS''", NEW_YORK, Locale.US);
+        assertEquals(cal.getTime(), fdf.parse("'20030210A'B153320989'"));
+    }
+
+    @Test
+    public void testSpecialCharacters() throws Exception {
+        testSdfAndFdp("q" ,"", true); // bad pattern character (at present)
+        testSdfAndFdp("Q" ,"", true); // bad pattern character
+        testSdfAndFdp("$" ,"$", false); // OK
+        testSdfAndFdp("?.d" ,"?.12", false); // OK
+        testSdfAndFdp("''yyyyMMdd'A''B'HHmmssSSS''", "'20030210A'B153320989'", false); // OK
+        testSdfAndFdp("''''yyyyMMdd'A''B'HHmmssSSS''", "''20030210A'B153320989'", false); // OK
+        testSdfAndFdp("'$\\Ed'" ,"$\\Ed", false); // OK
+    }
+
+    @Test
+    public void testLANG_832() throws Exception {
+        testSdfAndFdp("'d'd" ,"d3", false); // OK
+        testSdfAndFdp("'d'd'","d3", true); // should fail (unterminated quote)
+    }
+
+    @Test
+    public void testLANG_831() throws Exception {
+        testSdfAndFdp("M E","3  Tue", true);
+    }
+
+    private void testSdfAndFdp(final String format, final String date, final boolean shouldFail)
+            throws Exception {
+        final boolean debug = false;
+        Date dfdp = null;
+        Date dsdf = null;
+        Throwable f = null;
+        Throwable s = null;
+
+        try {
+            final SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);
+            sdf.setTimeZone(NEW_YORK);
+            dsdf = sdf.parse(date);
+            if (shouldFail) {
+                Assert.fail("Expected SDF failure, but got " + dsdf + " for ["+format+","+date+"]");
+            }
+        } catch (final Exception e) {
+            s = e;
+            if (!shouldFail) {
+                throw e;
+            }
+            if (debug) {
+                System.out.println("sdf:"+format+"/"+date+"=>"+e);
+            }
+        }
+
+        try {
+            final DateParser fdp = getInstance(format, NEW_YORK, Locale.US);
+            dfdp = fdp.parse(date);
+            if (shouldFail) {
+                Assert.fail("Expected FDF failure, but got " + dfdp + " for ["+format+","+date+"] using "+((FastDateParser)fdp).getParsePattern());
+            }
+        } catch (final Exception e) {
+            f = e;
+            if (!shouldFail) {
+                throw e;
+            }
+            if (debug) {
+                System.out.println("fdf:"+format+"/"+date+"=>"+e);
+            }
+        }
+        // SDF and FDF should produce equivalent results
+        assertTrue("Should both or neither throw Exceptions", (f==null)==(s==null));
+        assertEquals("Parsed dates should be equal", dsdf, dfdp);
+        if (debug) {
+            System.out.println(format + "," + date + " => " + dsdf);
+        }
+    }
+
+    @Test
+    public void testDayOf() throws ParseException {
+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
+        cal.clear();
+        cal.set(2003, 1, 10);
+
+        final DateParser fdf = getInstance("W w F D y", NEW_YORK, Locale.US);
+        assertEquals(cal.getTime(), fdf.parse("3 7 2 41 03"));
+    }
+
+    /**
+     * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}.
+     * @throws ParseException
+     */
+    @Test
+    public void testShortDateStyleWithLocales() throws ParseException {
+        DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);
+        final Calendar cal = Calendar.getInstance();
+        cal.clear();
+
+        cal.set(2004, 1, 3);
+        assertEquals(cal.getTime(), fdf.parse("2/3/04"));
+
+        fdf = getDateInstance(FastDateFormat.SHORT, SWEDEN);
+        assertEquals(cal.getTime(), fdf.parse("2004-02-03"));
+    }
+
+    /**
+     * Tests that pre-1000AD years get padded with yyyy
+     * @throws ParseException
+     */
+    @Test
+    public void testLowYearPadding() throws ParseException {
+        final DateParser parser = getInstance(YMD_SLASH);
+        final Calendar cal = Calendar.getInstance();
+        cal.clear();
+
+        cal.set(1,0,1);
+        assertEquals(cal.getTime(), parser.parse("0001/01/01"));
+        cal.set(10,0,1);
+        assertEquals(cal.getTime(), parser.parse("0010/01/01"));
+        cal.set(100,0,1);
+        assertEquals(cal.getTime(), parser.parse("0100/01/01"));
+        cal.set(999,0,1);
+        assertEquals(cal.getTime(), parser.parse("0999/01/01"));
+    }
+
+    /**
+     * @throws ParseException
+     */
+    @Test
+    public void testMilleniumBug() throws ParseException {
+        final DateParser parser = getInstance(DMY_DOT);
+        final Calendar cal = Calendar.getInstance();
+        cal.clear();
+
+        cal.set(1000,0,1);
+        assertEquals(cal.getTime(), parser.parse("01.01.1000"));
+    }
+
+    @Test
+    public void testLang303() throws ParseException {
+        DateParser parser = getInstance(YMD_SLASH);
+        final Calendar cal = Calendar.getInstance();
+        cal.set(2004, 11, 31);
+
+        final Date date = parser.parse("2004/11/31");
+
+        parser = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) parser));
+        assertEquals(date, parser.parse("2004/11/31"));
+    }
+
+    @Test
+    public void testLang538() throws ParseException {
+        final DateParser parser = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", GMT);
+
+        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT-8"));
+        cal.clear();
+        cal.set(2009, 9, 16, 8, 42, 16);
+
+        assertEquals(cal.getTime(), parser.parse("2009-10-16T16:42:16.000Z"));
+    }
+
+    @Test
+    public void testEquals() {
+        final DateParser parser1= getInstance(YMD_SLASH);
+        final DateParser parser2= getInstance(YMD_SLASH);
+
+        assertEquals(parser1, parser2);
+        assertEquals(parser1.hashCode(), parser2.hashCode());
+
+        assertFalse(parser1.equals(new Object()));
+    }
+
+    @Test
+    public void testToStringContainsName() {
+        final DateParser parser= getInstance(YMD_SLASH);
+        assertTrue(parser.toString().startsWith("FastDate"));
+    }
+
+    @Test
+    public void testPatternMatches() {
+        final DateParser parser= getInstance(yMdHmsSZ);
+        assertEquals(yMdHmsSZ, parser.getPattern());
+    }
+
+    @Test
+    public void testLocaleMatches() {
+        final DateParser parser= getInstance(yMdHmsSZ, SWEDEN);
+        assertEquals(SWEDEN, parser.getLocale());
+    }
+
+    @Test
+    public void testTimeZoneMatches() {
+        final DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK);
+        assertEquals(REYKJAVIK, parser.getTimeZone());
+    }
+}
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java
index ea0793ce..0f305841 100644
--- a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java
+++ b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java
@@ -263,26 +263,29 @@ public class FastDatePrinterTest {
     }
     
     @Test
-    public void testCalendarTimezoneRespected() {
-        final String[] availableZones = TimeZone.getAvailableIDs();
-        final TimeZone currentZone = TimeZone.getDefault();
-        
-        TimeZone anotherZone = null;
-        for (final String zone : availableZones) {
-            if (!zone.equals(currentZone.getID())) {
-                anotherZone = TimeZone.getTimeZone(zone);
-            }
-        }
-        
-        assertNotNull("Cannot find another timezone", anotherZone);
-        
-        final String pattern = "h:mma z";
-        final Calendar cal = Calendar.getInstance(anotherZone);
-        
-        final SimpleDateFormat sdf = new SimpleDateFormat(pattern);
-        sdf.setTimeZone(anotherZone);
-        final String expectedValue = sdf.format(cal.getTime());
-        final String actualValue = FastDateFormat.getInstance(pattern).format(cal);
-        assertEquals(expectedValue, actualValue);
-    }
+    public void testCalendarTimezoneRespected() {}
+// Defects4J: flaky method
+//     @Test
+//     public void testCalendarTimezoneRespected() {
+//         final String[] availableZones = TimeZone.getAvailableIDs();
+//         final TimeZone currentZone = TimeZone.getDefault();
+//         
+//         TimeZone anotherZone = null;
+//         for (final String zone : availableZones) {
+//             if (!zone.equals(currentZone.getID())) {
+//                 anotherZone = TimeZone.getTimeZone(zone);
+//             }
+//         }
+//         
+//         assertNotNull("Cannot find another timezone", anotherZone);
+//         
+//         final String pattern = "h:mma z";
+//         final Calendar cal = Calendar.getInstance(anotherZone);
+//         
+//         final SimpleDateFormat sdf = new SimpleDateFormat(pattern);
+//         sdf.setTimeZone(anotherZone);
+//         final String expectedValue = sdf.format(cal.getTime());
+//         final String actualValue = FastDateFormat.getInstance(pattern).format(cal);
+//         assertEquals(expectedValue, actualValue);
+//     }
 }
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java.bak b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java.bak
new file mode 100644
index 00000000..ea0793ce
--- /dev/null
+++ b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java.bak
@@ -0,0 +1,288 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.io.Serializable;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.TimeZone;
+
+import org.apache.commons.lang3.SerializationUtils;
+import org.junit.Test;
+
+/**
+ * Unit tests {@link org.apache.commons.lang3.time.FastDatePrinter}.
+ *
+ * @since 3.0
+ */
+public class FastDatePrinterTest {
+    
+    private static final String YYYY_MM_DD = "yyyy/MM/dd";
+    private static final TimeZone NEW_YORK = TimeZone.getTimeZone("America/New_York");
+    private static final Locale SWEDEN = new Locale("sv", "SE");
+
+        DatePrinter getInstance(final String format) {
+        return getInstance(format, TimeZone.getDefault(), Locale.getDefault());
+    }
+
+    private DatePrinter getDateInstance(final int dateStyle, final Locale locale) {
+        return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault());
+    }
+
+    private DatePrinter getInstance(final String format, final Locale locale) {
+        return getInstance(format, TimeZone.getDefault(), locale);
+    }
+
+    private DatePrinter getInstance(final String format, final TimeZone timeZone) {
+        return getInstance(format, timeZone, Locale.getDefault());
+    }
+
+    /**
+     * Override this method in derived tests to change the construction of instances
+     * @param format
+     * @param timeZone
+     * @param locale
+     * @return
+     */
+    protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) {
+        return new FastDatePrinter(format, timeZone, locale);
+    }
+
+    @Test
+    public void testFormat() {
+        final Locale realDefaultLocale = Locale.getDefault();
+        final TimeZone realDefaultZone = TimeZone.getDefault();
+        try {
+            Locale.setDefault(Locale.US);
+            TimeZone.setDefault(NEW_YORK);
+
+            final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);
+            final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);
+            final Date date1 = cal1.getTime();
+            final Date date2 = cal2.getTime();
+            final long millis1 = date1.getTime();
+            final long millis2 = date2.getTime();
+
+            DatePrinter fdf = getInstance("yyyy-MM-dd'T'HH:mm:ss");
+            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
+            assertEquals(sdf.format(date1), fdf.format(date1));
+            assertEquals("2003-01-10T15:33:20", fdf.format(date1));
+            assertEquals("2003-01-10T15:33:20", fdf.format(cal1));
+            assertEquals("2003-01-10T15:33:20", fdf.format(millis1));
+            assertEquals("2003-07-10T09:00:00", fdf.format(date2));
+            assertEquals("2003-07-10T09:00:00", fdf.format(cal2));
+            assertEquals("2003-07-10T09:00:00", fdf.format(millis2));
+
+            fdf = getInstance("Z");
+            assertEquals("-0500", fdf.format(date1));
+            assertEquals("-0500", fdf.format(cal1));
+            assertEquals("-0500", fdf.format(millis1));
+
+            assertEquals("-0400", fdf.format(date2));
+            assertEquals("-0400", fdf.format(cal2));
+            assertEquals("-0400", fdf.format(millis2));
+
+            fdf = getInstance("ZZ");
+            assertEquals("-05:00", fdf.format(date1));
+            assertEquals("-05:00", fdf.format(cal1));
+            assertEquals("-05:00", fdf.format(millis1));
+
+            assertEquals("-04:00", fdf.format(date2));
+            assertEquals("-04:00", fdf.format(cal2));
+            assertEquals("-04:00", fdf.format(millis2));
+
+            final String pattern = "GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M" +
+                " dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z";
+            fdf = getInstance(pattern);
+            sdf = new SimpleDateFormat(pattern);
+            // SDF bug fix starting with Java 7
+            assertEquals(sdf.format(date1).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date1));
+            assertEquals(sdf.format(date2).replaceAll("2003 03 03 03", "2003 2003 03 2003"), fdf.format(date2));
+        } finally {
+            Locale.setDefault(realDefaultLocale);
+            TimeZone.setDefault(realDefaultZone);
+        }
+    }
+
+    /**
+     * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}.
+     */
+    @Test
+    public void testShortDateStyleWithLocales() {
+        final Locale usLocale = Locale.US;
+        final Locale swedishLocale = new Locale("sv", "SE");
+        final Calendar cal = Calendar.getInstance();
+        cal.set(2004, 1, 3);
+        DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale);
+        assertEquals("2/3/04", fdf.format(cal));
+
+        fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale);
+        assertEquals("2004-02-03", fdf.format(cal));
+
+    }
+
+    /**
+     * Tests that pre-1000AD years get padded with yyyy
+     */
+    @Test
+    public void testLowYearPadding() {
+        final Calendar cal = Calendar.getInstance();
+        final DatePrinter format = getInstance(YYYY_MM_DD);
+
+        cal.set(1,0,1);
+        assertEquals("0001/01/01", format.format(cal));
+        cal.set(10,0,1);
+        assertEquals("0010/01/01", format.format(cal));
+        cal.set(100,0,1);
+        assertEquals("0100/01/01", format.format(cal));
+        cal.set(999,0,1);
+        assertEquals("0999/01/01", format.format(cal));
+    }
+    /**
+     * Show Bug #39410 is solved
+     */
+    @Test
+    public void testMilleniumBug() {
+        final Calendar cal = Calendar.getInstance();
+        final DatePrinter format = getInstance("dd.MM.yyyy");
+
+        cal.set(1000,0,1);
+        assertEquals("01.01.1000", format.format(cal));
+    }
+
+    /**
+     * testLowYearPadding showed that the date was buggy
+     * This test confirms it, getting 366 back as a date
+     */
+    @Test
+    public void testSimpleDate() {
+        final Calendar cal = Calendar.getInstance();
+        final DatePrinter format = getInstance(YYYY_MM_DD);
+
+        cal.set(2004,11,31);
+        assertEquals("2004/12/31", format.format(cal));
+        cal.set(999,11,31);
+        assertEquals("0999/12/31", format.format(cal));
+        cal.set(1,2,2);
+        assertEquals("0001/03/02", format.format(cal));
+    }
+
+    @Test
+    public void testLang303() {
+        final Calendar cal = Calendar.getInstance();
+        cal.set(2004, 11, 31);
+
+        DatePrinter format = getInstance(YYYY_MM_DD);
+        final String output = format.format(cal);
+
+        format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format));
+        assertEquals(output, format.format(cal));
+    }
+
+    @Test
+    public void testLang538() {
+        // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)
+        // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone
+        final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));
+        cal.clear();
+        cal.set(2009, 9, 16, 8, 42, 16);
+
+        final DatePrinter format = getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));
+        assertEquals("dateTime", "2009-10-16T16:42:16.000Z", format.format(cal.getTime()));
+        assertEquals("dateTime", "2009-10-16T08:42:16.000Z", format.format(cal));
+    }
+
+    @Test
+    public void testLang645() {
+        final Locale locale = new Locale("sv", "SE");
+
+        final Calendar cal = Calendar.getInstance();
+        cal.set(2010, 0, 1, 12, 0, 0);
+        final Date d = cal.getTime();
+
+        final DatePrinter fdf = getInstance("EEEE', week 'ww", locale);
+
+        assertEquals("fredag, week 53", fdf.format(d));
+    }
+    
+    @Test
+    public void testEquals() {
+        final DatePrinter printer1= getInstance(YYYY_MM_DD);
+        final DatePrinter printer2= getInstance(YYYY_MM_DD);
+
+        assertEquals(printer1, printer2);
+        assertEquals(printer1.hashCode(), printer2.hashCode());        
+
+        assertFalse(printer1.equals(new Object()));
+    }
+    
+    @Test
+    public void testToStringContainsName() {
+        final DatePrinter printer= getInstance(YYYY_MM_DD);
+        assertTrue(printer.toString().startsWith("FastDate"));
+    }
+    
+    @Test
+    public void testPatternMatches() {
+        final DatePrinter printer= getInstance(YYYY_MM_DD);
+        assertEquals(YYYY_MM_DD, printer.getPattern());
+    }
+    
+    @Test
+    public void testLocaleMatches() {
+        final DatePrinter printer= getInstance(YYYY_MM_DD, SWEDEN);
+        assertEquals(SWEDEN, printer.getLocale());
+    }
+    
+    @Test
+    public void testTimeZoneMatches() {
+        final DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK);
+        assertEquals(NEW_YORK, printer.getTimeZone());
+    }
+    
+    @Test
+    public void testCalendarTimezoneRespected() {
+        final String[] availableZones = TimeZone.getAvailableIDs();
+        final TimeZone currentZone = TimeZone.getDefault();
+        
+        TimeZone anotherZone = null;
+        for (final String zone : availableZones) {
+            if (!zone.equals(currentZone.getID())) {
+                anotherZone = TimeZone.getTimeZone(zone);
+            }
+        }
+        
+        assertNotNull("Cannot find another timezone", anotherZone);
+        
+        final String pattern = "h:mma z";
+        final Calendar cal = Calendar.getInstance(anotherZone);
+        
+        final SimpleDateFormat sdf = new SimpleDateFormat(pattern);
+        sdf.setTimeZone(anotherZone);
+        final String expectedValue = sdf.format(cal.getTime());
+        final String actualValue = FastDateFormat.getInstance(pattern).format(cal);
+        assertEquals(expectedValue, actualValue);
+    }
+}
